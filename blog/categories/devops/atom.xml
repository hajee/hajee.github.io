<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: devops | People & Software]]></title>
  <link href="http://hajee.github.io/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://hajee.github.io/"/>
  <updated>2014-02-23T15:01:02+01:00</updated>
  <id>http://hajee.github.io/</id>
  <author>
    <name><![CDATA[Bert Hajee]]></name>
    <email><![CDATA[hajee@moretIA.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Puppet to manage Oracle]]></title>
    <link href="http://hajee.github.io/2014/02/23/using-puppet-to-manage-oracle/"/>
    <updated>2014-02-23T08:01:51+01:00</updated>
    <id>http://hajee.github.io/2014/02/23/using-puppet-to-manage-oracle</id>
    <content type="html"><![CDATA[Russ looked at his screen. He started to get a bit weary. How in heavens name would he be able to manage this. He was looking at the requests he had for twenty applications that all had specific Oracle database needs. All different with regards to tablespaces, users, rights and services. And if that wasn’t bad enough in itself, all of the project teams building those applications, had up to 5 specific environments with different sizes and sometimes other settings. Russ definitely could use some help with this.

If you are like Russ in dire need of help manageing your Oracle databases, you should checkout this blog post. It describes a Puppet module we are building and already using to manage the dba objects of an Oracle database.

<!-- more -->

##The requirements

After discovering the [Puppet Oracle module](https://forge.puppetlabs.com/hajee/oracle), Russ felt a little bit less anxious. This could really make life a bit more easy.

First Russ started to look at the PIO application. The requirements for installing the PIO application where:

 1. An Oracle tablespace named `PIO_DATA` with a size of 200 Gigabyte
 2. An oracle user `PIO_USER` with the default tablespace set to `PIO_DATA` and only `connect`, `select any table` and `create table` rights. Also the user must have unlimited quota's in the `PIO_DATA` tablespace
 3. An Oracle role `PIO_APPLICATION_USER`
 4. A Service named like the application. So a  `PIO` service.

<sup>(This list is slimmed down a bit to make it more readable.)</sup>

##The PIO Tablespace

Let's start with the tablespace requirement. With the new found Oracle module, this looks like a strait forward Puppet definition. This code should do the trick:

```ruby
tablespace {'PIO_DATA':
  ensure                    => present,
  bigfile                   => yes
  datafile                  => 'pio_data.dbf'
  size                      => 200G,
  logging                   => yes,
  autoextend                => on,
  next                      => 100M,
  max_size                  => 12288M,
  extent_management         => local,
  segment_space_management  => auto,
}
```

So that takes care of requirement 1. let's test it.

Wait, the Oracle module doesn't install Oracle itself. What good is a module like this if you haven't gotten Oracle installed. Fortunately Russ found [Edwin Biemond's Oracle DB module](https://forge.puppetlabs.com/biemond/oradb) to take care of the installation.

##The PIO User

The oracle user `PIO` is a little bit more difficult. It has a default tablespace. So we must make sure the tablespace already exist before we start creating the user.

```ruby
oracle_user{'PIO':
  temporary_tablespace      => temp,
  default_tablespace        => 'PIO_DATA',
  password                  => 'justapassword,
  require                   => Tablespace['PIO_DATA'],
  grants                    => ['SELECT ANY TABLE', 'CONNECT', 'CREATE TABLE'],
  quotas                    => {
                                  'PIO_DATA'  => 'unlimited'
                              },
}
```

Again this looks like a strait forward Puppet definition. No Exec's no if's, just an easy readable Puppet definition. Requirement 3 fulfilled.

##The PIO_APPLICATION_USER role and the PIO service

Making sure the role and the service exist, s super easy. Just look at this code: 

```ruby
role {'PIO_APPLICATION_ROLE':
  ensure    => present,
}

oracle_service{'PIO':
  ensure  => present,
}

```
This completes the list of requirements for one application. But when Russ looked at the other application's, he noticed a very similar pattern. A user, a tablespace a role and a service. Only the values of the different applications where different.

##Puppet defined types to the rescue

Puppet has some nice mechanisms to handle just this kind of repeating pattern. A `defined typ[e` . let's create this type to manage all of Russ's applications.

```ruby
define db::app(
  $tablespace_name    = "${name}_data",
  $password           = $name,
  $size               = 3072M,
  $maxsize            = 12288M,
  $next               = 100M,
  $user_rights        = ['SELECT ANY TABLE'
                        , 'CONNECT'
                        , 'CREATE TABLE'
                        ]
){
 # include the class that installes Oracle. to make sure
 # This defined type is run after the Oracle installation

  tablespace {$tablespace_name:
    ensure                    => present,
    size                      => $size,
    logging                   => yes,
    autoextend                => on,
    next                      => 100M,
    max_size                  => 12288M,
    extent_management         => local,
    segment_space_management  => auto,
  }

  oracle_user{$name:
    temporary_tablespace      => temp,
    default_tablespace        => $tablespace_name,
    password                  => $password,
    require                   => Tablespace[$tablespace_name],
    grants                    => [$user_rights],
    quotas                    => {
                                    "${tablespace_name}"  => 'unlimited'
                                  },
  }

  $app_role = "${name}_application_user"

  role {$app_role:
    ensure    => present,
  }

  oracle_service{$name:
    ensure  => present,
  }

}
```

##The new and improved PIO definition

With this defined type in place, the `PIO` definition becomes:

```ruby
class pio {
  db::app{ 'pio':
    size      => 200G,
    password  => 'justapassword'
  }
}
```

For all the other applications, you can make the same kind of definitions. Your `node.pp` file could read like this:

```ruby
node "basenode" {
  include pio
  include axe
  include bcc
  ...
}
```

##You want to start as well?

The code in the blog post is based on the [Puppet Oracle module](https://forge.puppetlabs.com/hajee/oracle). Checkout the [repository](https://github.com/hajee/oracle) if you want to see how we do it. This is a fresh project, so you might run into some bugs. Don't hesitate to register them at [the issue log](https://github.com/hajee/oracle/issues).

##You can help?

That would be great. We only have a couple of Oracle DBA objects covered right now. There are lot's more. It would really be nice if we could get this module covering a lot of Oracle stuff. Clone the [repository](https://github.com/hajee/oracle) make your enhancements and post a pull request.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puppet Custom Types, the easy way (part 2)]]></title>
    <link href="http://hajee.github.io/2014/02/08/puppet-custom-types-the-easy-way-part-2/"/>
    <updated>2014-02-08T13:57:20+01:00</updated>
    <id>http://hajee.github.io/2014/02/08/puppet-custom-types-the-easy-way-part-2</id>
    <content type="html"><![CDATA[In the [last blog post](/2014/01/26/puppet-custom-types-the-easy-way/), we started with our own custom type. We added the `easy_type` module, created the files necessary for getting started and got our custom running without any errors. We then added two lines to get into a state where Puppet was able to do an inventory of our systems. But a custom type not able to create, delete or modify the state of your system, wouldnt be very helpful. So in the blog post we are going to add that functionality to our custom_package type.

<!-- more -->

##Let's recap
Let's first look back at what we did last time. To get started with [easy_type](https://github.com/hajee/easy_type), we made sure `easy_type` is installed in the module path. We used `librarian-puppet` to get `easy_type` installed. After that,  we created the right directories and created a scaffold. Since the last blog post,  we have added the scaffold to the `easy_type`. This makes's it even easier to get started. To get it, use the next command:

```sh
cp -Rv easy_type/scaffold custom_package/lib/puppet
```

After we created the scaffold, we checked what puppet would do with the type and noticed `Puppet` didn't do anything, but also didn't complain. So a good start.

Then we added the 2 lines of code for getting the raw package information from the system. After that,  we added the 1 line of code that picked the name and version information from the raw package information. Then we had a working Puppet custom type. 

<img src="/images/custom_package_list.png" title="Index from custom_package" >

Wel working...Sort of. Because the type doesn't know yet how it can create, delete and modify resources. So that's what we're going to do next.

##How to create a resource in real life?
Like I said in the [last blog post](/2014/01/26/puppet-custom-types-the-easy-way/), a design goal of `easy_type` is to let you focus on the resource knowledge and let us do the Puppet stuff. So what is needed to create a new `custom_package` instance. To create a new `custom_package` instance, we need to install a package.

For `easy_type`,  it would be the easiest thing if we could use the same base command as we used to get an index. That would be the `rpm` command, but in this case the best way to install a package is a `yum` command.

```sh
yum -q install a_package
```

This would install the latest version. But what if we needed a specific version? Then `a_package` needs to be both the name and the version number, concatenated with a dash. For example:

```sh
yum -q install php-5.2.6-2
```

Will install php version 5.2.6-2

##And how to do it in the Puppet world?
So how do we get this knowledge into our own custom type? First we have to add the extra command (`yum`) that is used. We do this by changing the `set_command` line to:

```ruby
set_command [:rpm, :yum]
```

This line tells `easy_type` that we use `rpm` and `yum` as commands. Next we have to tell `easy_type` to use `yum` when we need to create a resource:

```ruby
on_create do |command_builder|
  command_builder.add do
    yum "install -y #{name}"
  end
end
```

But wait. What about the version number? Don't we need to do add it somewhere? And you are right. We need to add it at the definition of the property. At the property add the lines:

```ruby
on_apply do |command_builder| 
  command_builder.append do
    "-#{version}"
  end
end
```

The method is only run when we need to create a resource or when the attribute value in the manifest is different from the attribute value on the system. So in this case, because we create a resource the method is called. With the `append` method, we tell the `command_builder` to add some text to the string created before by the `command_builder.add`.

So now we are able to create a `custom_package` resource.

<img src="/images/custom_package_created.png" title="Install a package using custom_package type" >

##And now some destruction
Like we saw before, `yum` is the command used to install a package. `yum` is also used to uninstall a package and therefore delete a resource in the Puppet world. The command will be:

```sh
yum -q erase a_package
```
To get this wisdom into our custom type, we need to add some code to the `on_destroy` handler.

```ruby
on_destroy do | command_builder|
  command_builder.add do
    yum "erase -y #{name}"
  end
end
```

So besides indexing and creating, now our custom type is also ready for to destroy a resource.

<img src="/images/custom_package_destroy.png" title="Install a package using custom_package type" >

##How about modifying?

Like we did before, we want to focus on our knowledge of the resource. What do we do when we modify the version attribute? 

<blockquote><p>The on_modify handler is a naive implementation that does not handle downgrade properly. The correct implementation should compare against the installed software version and invoke package downgrade when appropriate. The code here is kept simple; for more complete examples, see the ~/src/puppet/lib/puppet/provider/packages directory.</p><footer><strong>Just like in the book Puppet Types and providers</strong></footer></blockquote>

So in our simple case, we just install the specified version. Actually we just do an `on_create`. So let's tell our type to behave like that.

```ruby
on_modify do | command_builder|
  on_create(command_builder)
end
```

So now when we change the version number, a different package is installed.

<img src="/images/custom_package_modified.png" title="Install a package using custom_package type" >

## AND TA TAAHH
Now we are ready. We have a Custom Puppet Type that has the ability to:

* Do an index
* create a new resource
* destroy/delete a resource
* and modify an existing resource

If we don't count the  boiler plate code, then we added just 18 lines of code to get this working. Not to bad.

##There's a lot more
Like I said in the introduction, this is really a simple example. Real life custom types are more difficult. So `easy_type` has some more functionality that is not shown in this examples. 

* support for standard mungers
* support for standard validators
* A lot of tricks in the command_builder so it's easy to build commands based on what Puppet thinks, needs to be done.
* support for extracting the definition of attributes and properties

If you would like to see more about `easy_type`, just let me know and I will see if we can do some more posts about it. For now, check the example source in the [github repository](https://github.com/hajee/my_own_easy_type). You can also check some [Oracle Custom Types](https://github.com/hajee/oracle) which are build upon `easy_type`. 

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puppet Custom Types, the easy way]]></title>
    <link href="http://hajee.github.io/2014/01/26/puppet-custom-types-the-easy-way/"/>
    <updated>2014-01-26T13:57:20+01:00</updated>
    <id>http://hajee.github.io/2014/01/26/puppet-custom-types-the-easy-way</id>
    <content type="html"><![CDATA[Robert scratched his head. How would he get a Puppet class to manage a complex resource on his systems? I guess I’ll have to make a Custom Type, he thought. But last time I looked into that, I noticed you need to know a lot about Puppet Internals. 

If you recognize this thought process, maybe it’s time to meet [easy_type](https://github.com/hajee/easy_type). Like the name says, easy type is designed to make it easy to build a Custom Puppet Type. In this article, we will introduce [easy_type](https://github.com/hajee/easy_type). We do this by taking you along on in the process of  making a Custom Type. In the process, we explain how `easy_type` actually makes it…… well easy to build a Custom Type. In the first part, we will show you how to get Puppet to see and index all your resources. In the next blog posts, we will enhance the Custom Type to be able to create, remove and modify existing resources.

<!-- more -->

##When to build a Custom Type

Well that’s an interesting question! The Puppet language is actually very versatile, and you can do anything with it. But why would you step out of puppet and into ruby to build a Custom Type? In one of his [excellent blog posts](http://garylarizza.com/blog/2013/11/25/fun-with-providers/), Gary Larizza explains it in one sentence: “Because 20 execs in a defined type… “. Another indication, you’d be better of on a Custom Type path instead of a defined type, is when you need to build one or more custom facts. 

<blockquote><p>What would drive someone to write a custom type and provider for Puppet anyhow? Afterall, you can do ANYTHING IMAGINABLE in the Puppet DSL*! After drawing back my sarcasm a bit, let me explain where the Puppet DSL tends to fall over and the idea of a custom type and provider starts becoming more than just an incredibly vivid dream:</p><p><ul><br/>	<li>You have more than a couple of exec statements in a single class/defined type that have multiple conditional properties like ‘onlyif’ and/or ‘unless’.</li><br/>	<li>You need to use pure Ruby to manipulate data and parse it through a system binary</li><br/>	<li>Your defined type has more conditional logic than your pre-nuptual agreement</li><br/>	<li>Any combination of similar arguments related to the above</li><br/></ul><br/>If the above sounds familiar to you, then you’re probably ready to build your own custom Puppet type and provider.</p><footer><strong>Gary Larizza in Fun With Puppet Providers</strong></footer></blockquote>

##Let’s get started

To get started, you first need to include `easy_type` in your `Puppetfile` or otherwise get it into your puppet directories. To add it to your `Puppetfile`, you can add the following line:

```ruby
mod "hajee/easy_type", :git => "git://github.com/hajee/easy_type.git"
```

After that run the librarian to add the right modules to your puppet tree:

```sh
librarian-puppet install
```

The `librarian` reads the `Puppetfile` and puts the nescecary files into your module tree. After this command, you can see `easy_type` in your  list of modules.

<img src="/images/easy_type_added.png" title="easy_type added to modules" >

Well that was easy. Now we have all the basic requirements in place to start. What better time then now to think about the resource you want to manage.

##How to manage the resource?
Because `easy_type` hides some of the Puppet intricacies from you, you can focus on the resource. To continue, you need to know how: 

-	get a list of all available resources? 
-	what’s important in a resource?
-	to create a resource?
-	to modify an existing resource
-	to remove one

This is the basic information you need to build a custom resource.

#An example please?

As an example I’ve picked the same Custom Type as is described in the book [“Puppet Types and Providers"](http://shop.oreilly.com/product/0636920026860.do).  This is an excellent book if you are into writing custom resources. It describes in great detail everything you must known and do to build a Custom Type in the standard puppet way. In the book they state:

<blockquote><p>the `custom_package` type is not intended to serve as a replacement of Puppet’s existing package type. It serves as an example of how to take advantage of the features of the type and provider APIs.</p><footer><strong>Puppet Types and Providers By Dan Bode</strong> <cite>Nan Liu</cite></footer></blockquote>

Of course, the same thing counts over here.

##A scaffold
To get started, it would be helfull if we have a scafffold. Let's say we want to name our own module `my_own_easy_type` and we name our own Custom Type `custom_package`. Let's start with creating the right directories. Go over to your module directory and create the following directories:

```sh
mkdir -p my_own_easy_type/lib/puppet/provider/custom_package
mkdir -p my_own_easy_type/lib/puppet/type/custom_package
``` 

The first code we need, is the next scaffold:

```ruby
require 'easy_type'

module Puppet

  newtype(:custom_package) do
    include EasyType

    # set_command(:the_righ_command)

    to_get_raw_resources do
      # What commando to give to get a list of all resource.
      # We need to return an Array of Hashes 
    end

    on_create do
      # What do we do to create a resource
    end

    on_modify do
      # What do we do to modify an existingresource
    end

    on_destroy do
      # What do we do to destroy/delete an existingresource
    end

    newparam(:name) do
      include EasyType
      isnamevar

      to_translate_to_resource do | raw_resource|
        # how to translate from the Hash-like raw resource to get the name
        # raw_resource.column_data(:name)
      end

    end

  end
end
```

Let's put it in `my_own_easy_type/lib/puppet/type/custom_package.rb`. The next file we need is the provider file.

```ruby
require 'easy_type'

Puppet::Type.type(:custom_package).provide(:simple) do
	include EasyType::Provider

  desc "Manage packages with easy_type"

  mk_resource_methods

end
```

We need to put that at `my_own_easy_type/lib/puppet/provider/easy_type/simple.rb`

##It works.... Well, kind of
Actually this is all you have to do to get the basic Puppet stuff in order. Now you can give the puppet command to get a view of all available resources:

```sh
puppet resource custom_package
```

And it shows..... nothing. No output. But what is more import at this stage, is no error's or warnings. Now we can start working on the thing we know best. How to get the information about our resource, a package in this example, out and manageable.

##Let's get the index of all packages
So let's change the `custom_package` so we can use Puppet to get a list of all resources. To do this, we need to add just a couple of lines. Lets first look at the method `to_get_raw_resources`. Its function is to return an Array containing all available resources you manage. Every Array entry is preferably a Hash. A Hash that contains the all the individual properties and parameters of an instance of your resource.

In our example,  we are managing packages. To get a list of packages on a Linux system, you can use the `rpm` command. The following os command returns a list of all packages formatted in a comma separated way containing its name and its version.

```sh
rpm -qa' --qf' %{NAME}, %{VERSION}\n
```

We would like the Custom Type to execute this command and convert the data to an Array of Hashes.

To do just that, we need to change the `to_get_raw_resources` method to:

```ruby
    to_get_raw_resources do
      packages_string = rpm('-qa','--qf','%{NAME}, %{VERSION}\n')
      convert_csv_data_to_hash(packages_string,[:name, :version])
    end
```
The `packages_string` will contain a string with all the information. The `convert_csv_data_to_hash` method will convert it to a hash. The elements in the hash are named `name` and `version`.

To let `easy_type` know rpm is an os command, we need to add the line:

```ruby
set_command(:rpm)
```

Now we need to let Puppet know how to get the name value from the raw resource. To do this, we change the definition of the name parameter.  We need to define the `to_translate_to_resource` method. Its function is to pick just the name out of the Hash that describes the full resource. You must define this function in every parameter or property. It receives a single instance of a resource in a Hash. It is one element from the Array of Hashes we created before. Because we named the first column in our comma separated data, `:name`, we can easily get it from the Hash. Lets define the function:

```
to_translate_to_resource do | raw_resource|
	raw_resource.column_data(:name)
end
```

##TA TAAHH

Now when we ask Puppet for the available `custom_packages`, we get a list of all the available packages.

```sh
puppet resource custom_package
```
Output:
```ruby
custom_package { 'GConf2':
  ensure  => 'present',
}
custom_package { 'MAKEDEV':
  ensure  => 'present',
}
...
```
But wait, didn't we also collect the version information? What about that? To Add the version information, we need to add a version property. A property looks very similar to the parameter that was already available in the scaffold. Here is the code for the version property:

```ruby
newproperty(:version) do
  include EasyType

  to_translate_to_resource do | raw_resource|
    raw_resource.column_data(:version)
  end
end
```

Now when we ask Puppet for the available `custom_packages` again, we get a list of all the available packages, inclusing the version information.

```sh
puppet resource custom_package
```
Output:

```ruby
custom_package { 'GConf2':
  ensure  => 'present',
  version => '2.14.0',
}
custom_package { 'MAKEDEV':
  ensure  => 'present',
  version => '3.23',
}
...
```

##Next...
In the [next blog post](/2014/02/08/puppet-custom-types-the-easy-way-part-2/), we will enhance our work. We will add support for changing existing resources. If, in the meanwhile you want to check `easy_type` out. You can checkout the source in the [github repository](https://github.com/hajee/easy_type). You can also check some [Oracle Custom Types](https://github.com/hajee/oracle) which are build upon `easy_type`. We would love to hear your feedback on this work. You can find the example [here](https://github.com/hajee/my_own_easy_type)

_Since first publication, some changes where made to the code fragments in this blog post. If you used the code in this post, please check the changes in the github repo_]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing your system installation with RSpec]]></title>
    <link href="http://hajee.github.io/2014/01/18/testing-your-system-installation-with-rspec/"/>
    <updated>2014-01-18T14:12:37+01:00</updated>
    <id>http://hajee.github.io/2014/01/18/testing-your-system-installation-with-rspec</id>
    <content type="html"><![CDATA[[In the last blog post](/2014/01/13/how-to-test-systems-installations/) we introduced described the need for a testing tool for Linux and middleware installations. After some Internet reasearch and a small test, we concluded  [RSpec](https://relishapp.com/rspec) would be a good fit. In this blog post,  we will dive into the way we use RSpec to build the specifications and tests needed for your systems.

<!-- more -->

##Our environment

Before we dive into RSpec, lets first describe our environment. Most of our applications use at least the combination of an Oracle database and a WebLogic JEE server. Sometimes the applications are also built using  Tibco products. Normally, all these middleware functions are installed on separate distinct systems. This means one or more  systems for the Oracle database. One or more systems for the WebLogic JEE server, and one or more systems for Tibco products. All these systems have interrelated settings. For example, the Weblogic server needs a connection to the Oracle database to get it's data. This group of interrelated systems, we call a platform. We build specifications and tests for a complete platform. So the specification contains all settings and tests for a set of 3 or more systems.

##What's this RSpec thing? 
RSpec is a tool based on the  [Behaviour Driven Development](http://en.wikipedia.org/wiki/Behavior-driven_development)(BDD) software development process. Wikipedia says:

<blockquote><p>At the heart of BDD is a rethinking of the approach to unit testing and acceptance testing that North came up with while dealing with these issues. For example, he proposes that unit test names be whole sentences starting with the word "should" and should be written in order of business value.</p></blockquote>

Heart of the matter is, you write specifications, and you accompany them with a test to validate the specification. Throughout this blog post, the terms specification (and spec) and tests are both used and mean (about) the same.
If you would like to know more about the RSpec core, I recommend checking out the [web site](https://www.relishapp.com/rspec/rspec-core/v/3-0/docs)  and to read the book [The RSpec Book: Behaviour-Driven Development with RSpec, Cucumber, and Friends](http://pragprog.com/book/achbd/the-rspec-book)

##The top spec

The code below shows what we call, a top level spec. As you can see, we use all the normal RSpec syntax. 

```ruby
describe "a top spec, 
	:with_domain => 'just.a.domain.com',
	:with_dbname => 'dbname' do

	include_context "running in our development network"

	host = 'dbhost'
	describe "RDBMS host", 
		:on_host => host,
		:with_ip => '10.0.0.1',
		:if => runs_on(host) do

		it_behaves_like "runs on DL380", 'M6', 4, '4G'
		it_behaves_like "a database server"
		it_behaves_like "database is configured for a specific application"

	end

	host = 'wlshost'
	describe "JEE host", 
		:on_host => host,
		:with_ip => '10.0.0.3',
		:if => runs_on(host) do

		it_behaves_like "runs on DL380", 'M6', 4, '4G'
		it_behaves_like "a WebLogic host"
		it_behaves_like "WebLogic is configured dor a specific application"
	end
end
```

If you read through the code, you can see, the top level spec, contains the specifications for all the systems in this platform. We have a `dbhost`. The spec for this system starts at line 8. The other system in the platform is the `wlshost`. Again: together, we call them a platform. To run the spec on either system, you can use the regular RSpec command:


```bash
$ rspec toplevel_spec.rb
```

The line `:on_host => host`, takes care that only the right set of spec's and tests are run on the system. If we enter this command on node `wlshost`, only line 15 trough to line 28 are run. On the other hand, if we run the command on host `dbhost`, only lines 13 until 15 are run. If you enter the command on any other system, nothings happens.

##Running in different environments
One of the design goals of our testing setup is that we want to be able to run the same set of tests in all of our environments. This means the same tests run in development, test, acceptance and even in production. To accomplish this, we make heavy use of RSpec's metadata.

```ruby
describe "RDBMS host", 
		:on_host => host,
		:with_ip => '10.0.0.1',
		:if => runs_on(host) do
```
The `:on_host => host` and the `:with_ip => '10.0.0.1'` are [user defined metadata elements](https://www.relishapp.com/rspec/rspec-core/v/3-0/docs/metadata/user-defined-metadata). Later in this blog post, I will show how we actually use this metadata to make the individual tests are unaffected by the environment the run in.

If you have more than a couple of environment specific settings, setting them all in the [`describe block`](https://www.relishapp.com/rspec/rspec-core/v/3-0/docs/example-groups/basic-structure-describe-it), would become quite large and cumbersome to read and understand. Therefore, we introduced the `include_context "running in our 
development network` in line 5. In this line,  we include a specific context or environment. 

In the shared_contexts, you can specify all sorts of metadata parameters. Because they are named, you can select which one you need. Right now, we use the one that works in our development network. The shared contexts can be written in another file. Here is the one we used:

```ruby
shared_context "running in our development network" do
	meta_for do
		domain			'just.a.domain.com'
		dns_servers		['12.88.129.19', '192.168.42.155']
		ntp_servers 		['192.168.80.4', '192.168.80.120', '127.127.1.0']
		netmask			'255.255.254.0'
		ldap_server		'ldap.domain.com'
		env				'd'
	end
end
```
 
In this `shared_context`,  we can specify all specific setting for an environment. What's even better, we can share it between different top level specs. So the top level spec's running in this environment, can include this shared context and have all nescecarry settings. It's also very [DRY](http://en.wikipedia.org/wiki/Don't_repeat_yourself) If you change your dns servers, there's only one place you have to change this value.

The [`shared_context`](https://www.relishapp.com/rspec/rspec-core/v/3-0/docs/example-groups/shared-context) idiom is RSpec standard. The `meta_for` is something we added. You can specify any legal ruby variable name on the left and any ruby type on the right side.

##structure of the spec's

Let's get back to the actual specification. Again we make heavy use of a standard RSpec feature. The [shared examples](https://www.relishapp.com/rspec/rspec-core/v/3-0/docs/example-groups/shared-examples).  Using `it_behaves_like`, we can call a set of specifications.
```ruby
it_behaves_like "runs on DL380", 'M6', 4, '4G'
it_behaves_like "a database server"
it_behaves_like "database is configured for a specific application"
```
We have a convention to structure the tests in three levels.

1. The hardware
2. The type of function of the system. E.g. a database or a JEE server 
3. The extra additions we need to get a specific application running on it.

##The real stuff

All the elements we talked about this far, are mostly stuff we need to structure the set of tests. But what does the real stuff look like? Here is part of the real stuff.

```ruby
shared_examples "using generic services" do
	describe "having LDAP service" do

		it "file /etc/ldap.conf exists" do
			System.files.should include "/etc/ldap.conf"
		end

		it "idle time limit for LDAP queries is set to 870" do
			System.files["/etc/ldap.conf"]["idle_timelimit"].should eq "870"
		end

		it "ldap url is set to ldap://#{meta(:ldap_server)}/" do
			System.files["/etc/ldap.conf"]["uri"].should eq ("ldap://" + meta(:ldap_server) + "/")
		end
	end

	describe "using generic DNS services" do
		it "file /etc/resolv.conf exists" do
			System.files.should include "/etc/resolv.conf"
		end

		it "dns servers are set to: #{meta(:dns_servers)}" do
			System.files["/etc/resolv.conf"]["nameserver"].should include *meta(:dns_servers)
		end

		it "DNS search list is set to: #{meta(:domain)}" do
			System.files["/etc/resolv.conf"]["search"].should eq_ignorecase meta(:domain)
		end

		it "is able to resolve FQDN (#{meta(:host)}.#{meta(:domain)})" do
			System.check_dns(meta(:host) + "." + meta(:domain)).should eq true
		end
	end
end
```

This is part of the specifications for the base Linux system. It describes the LDAP and DNS settings.  Here, you see the basic RSpec structure. We use `describe` to structure  a big set of specifications and tests into smaller units. The actual specifications are done using the `it` commands.  Our aim is to write communicable text in the `it` statement. We have noticed that besides a good test tool, RSpec really enabled us to communicate about what we did and why we did it.

The `System.files["/etc/ldap.conf"]["idle_timelimit"].should eq "870"` is the actual test. Also in this code, we place a high value on communication. Even someone who doesn't know anything about RSpec and ruby, but knows about LDAP, is able to understand that we test if the `idle_timelimit` in `/etc/ldap.conf` is set to 870.

##What does that meta thing do?
I told you before that we make heavy use of Rspec's user defined metadata. We define the information either in the describe block or we can describe them in the shared_context's. But in the test, is where we actually use them. Let's look at one in detail.

```ruby
it "dns servers are set to: #{meta(:dns_servers)}" do
	System.files["/etc/resolv.conf"]["nameserver"].should include *meta(:dns_servers)
end
```

This specification text contains a call to the `meta` method with the parameter `:dns_servers`. This call looks into the meta information that's available and retrieves the value for `:dns_servers`. If you check back to the `shared_context`, you can see, that it translates to `['12.88.129.19', '192.168.42.155']`. So when this specification is run, the description of the specification will become:

```
dns servers are set to: ["12.88.129.19", "192.168.42.155"]
```

In the test itself,  the `*meta(:dns_servers)` will also be translated to the array with the two string values.

This `meta` method is **not** standard RSpec. In standard RSpec,  there is a difference between meta information you can use on the description level and the meta information you can use in the test. We felt that it would be useful to use them equally in both the description and the test. So we build our own extension to the RSpec meta information.

##The **real** real stuff
I said before that I would show you the real stuff. But that was a small lie. The `System` class you see in the example is an abstraction. An abstraction we use to keep the spec's and tests at that level very readable and with a high communication value. Did I tell you the value we put on communication ;-). But **NOW** I',m going to show you the real stuff. Here.... without further ado, is the `System` class:
 
```ruby
class System
	def self.files
		Facter.value("system_files")
	end
	
	def self.service_startup
		return Facter.fact("service_startup").value
	end
end
```

In the `System class`,  we use the [Facter gem](http://puppetlabs.com/facter).

<blockquote><p>Facter is a lightweight program that gathers basic node information about the hardware and operating system. Facter is especially useful for retrieving things like operating system names, hardware characteristics, IP addresses, MAC addresses, and SSH keys.</p></blockquote>

With facter,  we retrieve all sorts of information from the operating system and middleware in a way that we can easily use it in our spec's (Or in a puppet manifest). Depending on the kind of information, it returns an integer, an array, a string or even a [hash](http://ruby-doc.org/core-2.1.0/Hash.html). Returning a hash helps in making the higher level tests very easy to read. Let me give you an example. Let's look at the test below:

```ruby
it "idle time limit for LDAP queries is set to 870" do
	System.files["/etc/ldap.conf"]["idle_timelimit"].should eq "870"
end
```

It calls the `files` method on the `System` class.  We've seen the files method calling the `system_files`  fact. The fact returns the following information:

```ruby
	"/etc/anther_file" => {...}
	"/etc/ldap.conf"  => {
		"idle_timelimit"  		=>  "870", 
		"another_setting"     =>  "nonsense"
	}
}
```

That's why it is easy to get the `idele_timelimit` from `/etc/ldap.conf`

##Whats next...
Next time, I'm going to tell you a bit about the work we did to make it easier to build custom types and resources for Puppet. Stay tuned.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to test systems installations]]></title>
    <link href="http://hajee.github.io/2014/01/13/how-to-test-systems-installations/"/>
    <updated>2014-01-13T20:14:10+01:00</updated>
    <id>http://hajee.github.io/2014/01/13/how-to-test-systems-installations</id>
    <content type="html"><![CDATA[Just imagine yourself installing a Linux system with an Oracle database and a WebLogic application server. There are a lot of manual steps that have to be taken. A lot of commands to be typed and a lot of configurations to be set right in order to get the perfect system for the application. A lot of things can go wrong. You can miss a configuration setting. You can forget a command. Hopefully you get an error message because you did something wrong, but it can also turn out te be a silent error. One you only see after you have given the system to the application developers, or worse one that only comes out after the system is running in production and some load is put onto it. Hoe do we make sure a system is correct after the installation. In this blog post,  I will describe how we used Rspec to test out installations.

<!-- more -->

## How it's done mostly
In the area's of interest for continuous deployment, testing is a separate topic. Although testing  has become mainstream in regular software development, testing isn't really that mainstream when it comes to environments and deployments. Certainly not automated testing. Most of the times, the operations guy checks a couple of items on a checklist. Does the system boot well? Are there any error messages during the boot? Can I log in as root? Can I ping to the router? Can I connect to the database? All good tests, but hardly sufficient.

##It's quite big and complex
Actualy te be certain a system is installed correctly, is a rather complex and big task. There are numerous configuration files and settings. Every individual setting might cause the system to misbehave. Not only that, but the settings are also interrelated. Sometimes, if I change setting X, then I must also change setting Y. If for example I change the hostname of a Linux system, I might also have to change the hostname for the web server.

From research,  we know that the human brain is very powerful. But it lacks the capacity to see and manage a lot of intricate small little details. So even a very clever devops engineer can easily forget the extra change in setting Y after he changes setting X.

##how can we manage?
We could of course after an installation have QA check all settings. Because there are so many of the small little, but important settings, this would become a very labour intensive task. Not to mention a tedious and an error prone task. We need help. Just like in regular software development, we need to test our units with automated tests. The units can be the different kinds of settings. In the figure below you see an extract of running a unit-test for  a Linux installation.

<img src="/images/rspec_output.png" title="Part of an Rspec report on an installation" >


##What tools do we need?
The market for testing tools for regular software is crowded. A lot of good tools and frameworks exist for that kind of work. The market for testing tools for devops is a lot more dense. We decided to use [RSpec](https://relishapp.com/rspec) a tool mostly used in behaviour driven software development in the [Ruby world](https://www.ruby-lang.org/en/). We choose Rspec because of these reasons:

- After a small test, it really seemed to fit
- It is not only great as a test tool but even better as a communication tool (more on that later)
- It is open source and therefore we don't need any expensive license
- It has a large and vibrant user community
- Because we were aiming at using [Puppet](http://puppetlabs.com/puppet/puppet-enterprise), we needed Ruby on our systems anyway.

##Communication
One of the best things of RSpec is the clarity of its reporting. We noticed that the RSpec reports, where a means of discussion between the different stakeholders. In the past,  we'd have these vague discussions about a setting. Not all stakeholders new what the setting meant and why it was setup this way. After using RSpec, all of a sudden, we could pinpoint a certain setting and have a meaningful discussion about the reason of the setting and the actual value.

##How we use it?

Like I explained before, we are using the automated tests to check our settings. This means we mostly do checks on those sometimes we do a little bit more. For example, when we check the settings of the DNS resolver on a system, it is quite easy to extend the test to do a lookup and a reverse lookup to assess if it is really working.

On the other hand, if a new package solves a certain bug, it is easy to test if a certain version of that package is installed =, but quite hard to simulate the bug te check if it is actually solved. So we don't do that.

##Is the test sufficient?
**NO** definitely not. Just like the unit-tests of a regular application is insufficient. the RSpec tests are just a first kind of smoke test. But we noticed it is a very valuable one. After the RSpec tests are done, you still need acceptance and integration tests. Preferably with the application and all related middleware installed.

##Next...
In the [next blog post](/2014/01/18/testing-your-system-installation-with-rspec/)  I will explain how we have structured our Rspec code. ]]></content>
  </entry>
  
</feed>
